# BehaviorOS V4.0 契约×代码对齐审计指令

## 目标

对 `core/models.py`(100个ORM模型)、`api/`(63个API模块)、`core/`(全部服务)、`agents/`、`behavior_rx/` 进行全面扫描，与契约注册表14Sheet进行双向对齐审计，输出一份结构化报告。

## 审计范围

### A. 正向扫描（注册表→代码）

检查契约注册表的每项核心治理需求是否有代码实现：

**①平台角色架构** — 6级成长轨 + 治理轨
- [ ] Observer/Grower/Sharer/Coach/SeniorCoach/Master 是否在 UserRole 枚举中完整对应
- [ ] L2.5实习教练角色是否有实现
- [ ] 双轨制（成长轨+治理轨）是否在代码中有区分逻辑

**②治理轨契约**
- [ ] Admin/Supervisor 的治理逻辑是否与角色架构一致
- [ ] 督导专家三重角色（领域专家/质量督导/生态建设）是否在代码中有区分

**③访客与入口契约**
- [ ] Observer分层（免注册/注册）是否有路由守卫实现
- [ ] 体验版评估(限1次)和AI体验对话(限3轮)的限制逻辑
- [ ] 四渠道入口（社区/医疗/消费/自然）识别

**④晋级契约**
- [ ] 双轨晋级校验引擎（积分轨自动+成长轨触发）→ 对应 `DualTrackStatus` 模型
- [ ] 4种晋级状态（normal_growth/points_ready/growth_ready/ceremony_pending）
- [ ] 晋级仪式触发逻辑

**⑤服务权益契约**
- [ ] 66行×10列的服务权益矩阵，是否有RBAC实现对应
- [ ] 内容等级门控（L0-L5 × 角色可见性）

**⑥责任追踪契约**
- [ ] 36条责任×自动化指标 → 对应 `ResponsibilityMetric` 模型
- [ ] governance_health_check 服务是否存在

**⑦积分契约**
- [ ] 三类积分（成长/贡献/影响力）→ 对应 `PointTransaction`/`UserPoint`/`UserPointBalance`
- [ ] 10种治理积分事件 → 对应 `PointEvent` 模型
- [ ] 六种防刷策略（AS-01~06）→ 对应 `AntiCheatEvent` + `core/anti_cheat_engine.py`

**⑧生命周期契约**
- [ ] S0-S5阶段流转 → `JourneyState` + `core/stage_engine.py`
- [ ] 90天稳定验证逻辑
- [ ] 中断检测+自动退出机制 → `core/auto_exit_handler.py`

**⑨治理触点契约**
- [ ] 22行治理触点是否有API对应

**⑩技术实施映射**
- [ ] 55行映射项逐项检查代码实现状态

**⑪教练体系管理**
- [ ] 教练KPI红绿灯仪表盘 (10项KPI)
- [ ] 教练三轨入口（内生/外部/平台）
- [ ] 5级教练层级管理
- [ ] 400分制考核系统
- [ ] 同道者追踪系统
- [ ] 收益分配系统
- [ ] 督导管理模块

**⑫督导专家×Agent生态**
- [ ] Agent双层架构（用户层/教练层）物理分离
- [ ] 10领域×Agent映射
- [ ] Agent市场发布→审核→上架流程

**⑬Rx引擎×Agent四级治理**
- [ ] 四级治理（预设/认证/标准/基础）→ AgentTemplate.governance_level
- [ ] Rx引擎三维+SPI四维 → behavior_rx_engine.py
- [ ] 12策略×领域变体 → rx_strategy_templates表
- [ ] 沙箱测试引擎 → sandbox_test_results表

**⑭采集×测评×交付治理**
- [ ] 26+数据源采集覆盖
- [ ] 5量表171题 → BAPS模块
- [ ] 5交付通道治理

### B. 反向扫描（代码→注册表）

逐个检查以下模块，标记哪些**在注册表中没有对应治理契约**：

#### API模块（63个 *_api.py）
逐个读取每个API文件的路由定义（@app.get/post/put/delete 或 APIRouter），列出每个模块的端点数量和功能摘要，标记是否与注册表某个Sheet对应。

#### ORM模型（100个）
逐个检查 core/models.py 中每个 class，标记是否被注册表覆盖。

#### Core服务
扫描 core/ 目录下所有 *_service.py 和 *_engine.py，标记覆盖情况。

### C. 冲突检测

检查以下已知的疑似冲突：

**C1. Agent系统三处并存**
- `agents/` (octopus_engine, router, orchestrator 等9模块)
- `core/agents/` (master_agent, coordinator, policy_gate 等10模块)
- `behavior_rx/agents/` (4个专病Agent)
- 问题：三者的职责边界、调用关系是什么？是否有重复实现？

**C2. Policy/策略 多处实现**
- `core/policy_engine.py`
- `core/brain/policy_gate.py`
- `core/agents/policy_gate.py`
- `behavior_rx/core/rx_conflict_resolver.py`
- `core/conflict_resolver.py`
- 问题：哪个是主入口？其余是否为调用链上游/下游？是否有逻辑冲突？

**C3. Stage/阶段 多处实现**
- `core/stage_engine.py`
- `core/stage_mapping.py`
- `core/brain/stage_runtime.py`
- `agents/octopus_fsm.py`
- 问题：S0-S5阶段判定的权威来源是哪个？

**C4. 模型字段冗余**
- `User.current_stage` (L188) vs `JourneyState.journey_stage` (L3999) — 同一信息两处存储
- `User.agency_mode/agency_score/trust_score` (L192-194) vs `JourneyState` 同名字段 (L4002-4008) — 完全重复
- `StageTransitionLog` (m019) vs `StageTransitionLogV4` (m033) — 同表名 extend_existing
- 问题：哪个是权威数据源？是否有同步机制？

**C5. 路由版本并存**
- `api/routers/` (8个文件)
- `api/v14/` (5个文件)
- `api/*.py` 顶层63个文件
- 问题：三层路由的分工是什么？v14是新版本还是旧版本？

**C6. 知识库重叠**
- `core/knowledge/` (7个文件：retriever, chunker, embedding, document_service 等)
- `core/rag/` (3个文件：knowledge_loader, pipeline, vector_store)
- `backend/services/` (chunker, doc_parser, ingest, retriever)
- 问题：三处知识库/RAG实现，哪个是活跃的？

## 输出格式

生成文件：`V4_契约代码对齐审计报告.md`

报告结构：
```
# 审计概要
- 审计时间
- 扫描范围统计（模型数/API数/服务数）
- 对齐率：已对齐/部分对齐/未对齐/脱管 各多少

# 一、正向对齐（注册表→代码）
按14个Sheet逐项列表，每项标注：
- ✅ 已对齐 — 代码完整实现
- ⚠️ 部分对齐 — 有实现但不完整或与注册表有偏差
- ❌ 未实现 — 注册表要求但代码中不存在
附具体文件路径和行号

# 二、反向扫描（代码→注册表）
按模块列表，每个标注：
- 🟢 对齐 — 在注册表中有对应治理契约
- 🟡 脱管 — 代码存在但注册表未覆盖（需决策：纳入/废弃/冻结）
- ⚫ 废弃 — 明确已废弃的代码（如 UserRole.PATIENT）

# 三、冲突清单
每个冲突项：
- 涉及文件列表
- 冲突描述
- 调用关系分析（谁调谁）
- 建议处理方案（合并/分层/废弃其一）

# 四、行动建议
按优先级排列的处理清单
```

## 执行方式

请逐个读取相关文件（不需要全部逐行读，读文件头、类定义、import、关键方法签名即可），与上述检查项交叉比对，生成报告。

对于C1-C6冲突项，请实际读取相关文件的import语句和调用关系来判断，不要猜测。
