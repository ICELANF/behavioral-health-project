#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
BehaviorOS Penetration Test Suite — automated security checks.

Tests: SQL injection, XSS, auth bypass, IDOR, path traversal, rate limiting,
header security, CORS, sensitive data exposure, JWT manipulation.

Usage:
    python scripts/pentest_bhp.py --base http://localhost:8000/api/v1 --json reports/pentest.json
"""

import argparse
import json
import os
import sys
import time
from datetime import datetime

try:
    import requests
    requests.packages.urllib3.disable_warnings()
except ImportError:
    print("pip install requests")
    sys.exit(1)


class PentestRunner:
    def __init__(self, base: str, json_path: str):
        self.base = base.rstrip("/")
        self.json_path = json_path
        self.session = requests.Session()
        self.session.verify = False
        self.timeout = 10
        self.findings = []
        self.tests_run = 0
        self.tests_passed = 0

        # Get tokens for different roles
        self.admin_token = None
        self.user_token = None
        self._login()

    def _login(self):
        """Get auth tokens for testing."""
        api_root = self.base.replace("/api/v1", "")
        login_url = f"{api_root}/api/v1/auth/login"

        # Admin login
        try:
            r = self.session.post(login_url, data={"username": "admin", "password": "Admin@2026"}, timeout=self.timeout)
            if r.status_code == 200:
                self.admin_token = r.json().get("access_token")
        except Exception:
            pass

        # Observer login
        try:
            r = self.session.post(login_url, data={"username": "observer", "password": "Observer@2026"}, timeout=self.timeout)
            if r.status_code == 200:
                self.user_token = r.json().get("access_token")
        except Exception:
            pass

    def _get(self, path, token=None, **kwargs):
        headers = {}
        if token:
            headers["Authorization"] = f"Bearer {token}"
        return self.session.get(f"{self.base}{path}", headers=headers, timeout=self.timeout, **kwargs)

    def _post(self, path, token=None, **kwargs):
        headers = {}
        if token:
            headers["Authorization"] = f"Bearer {token}"
        return self.session.post(f"{self.base}{path}", headers=headers, timeout=self.timeout, **kwargs)

    def _record(self, title, severity, detail):
        self.findings.append({"title": title, "severity": severity, "detail": detail})

    def _pass(self, name):
        self.tests_run += 1
        self.tests_passed += 1
        print(f"  PASS: {name}")

    def _fail(self, name, severity, detail):
        self.tests_run += 1
        self._record(name, severity, detail)
        print(f"  FAIL [{severity}]: {name} — {detail[:80]}")

    # ── Test categories ──

    def test_sql_injection(self):
        """Test common SQL injection vectors."""
        print("\n[1/10] SQL Injection")
        payloads = ["' OR '1'='1", "1; DROP TABLE users; --", "' UNION SELECT 1,2,3--"]
        safe = True
        for payload in payloads:
            try:
                r = self._get(f"/search?q={payload}", token=self.admin_token)
                body = r.text.lower()
                if any(kw in body for kw in ["syntax error", "pg_catalog", "sqlstate", "unterminated"]):
                    self._fail("SQL Injection via search", "HIGH", f"DB error leaked with payload: {payload[:30]}")
                    safe = False
                    break
            except Exception:
                pass
        if safe:
            self._pass("SQL Injection — no DB errors leaked")

    def test_xss_reflection(self):
        """Test reflected XSS in common parameters."""
        print("\n[2/10] XSS Reflection")
        payload = "<script>alert(1)</script>"
        safe = True
        for path in ["/search?q=", "/content?keyword="]:
            try:
                r = self._get(f"{path}{payload}", token=self.admin_token)
                if payload in r.text and "text/html" in r.headers.get("content-type", ""):
                    self._fail("Reflected XSS", "HIGH", f"Script tag reflected in {path}")
                    safe = False
                    break
            except Exception:
                pass
        if safe:
            self._pass("XSS Reflection — no unescaped reflection")

    def test_auth_bypass(self):
        """Test unauthenticated access to protected endpoints."""
        print("\n[3/10] Auth Bypass")
        protected = ["/users", "/coach/dashboard", "/admin/analytics/overview"]
        bypassed = []
        for path in protected:
            try:
                r = self._get(path)  # No token
                if r.status_code == 200:
                    bypassed.append(path)
            except Exception:
                pass
        if bypassed:
            self._fail("Auth Bypass", "CRITICAL", f"Unauthenticated access to: {', '.join(bypassed)}")
        else:
            self._pass("Auth Bypass — all protected endpoints require auth")

    def test_idor(self):
        """Test insecure direct object references."""
        print("\n[4/10] IDOR")
        # Observer trying to access admin user data
        if not self.user_token:
            self._pass("IDOR — skipped (no user token)")
            return
        safe = True
        try:
            # Observer tries to get admin's profile (id=2)
            r = self._get("/users/2", token=self.user_token)
            if r.status_code == 200:
                data = r.json()
                if data.get("password_hash") or data.get("password"):
                    self._fail("IDOR — password hash exposed", "CRITICAL", "User API returns password_hash")
                    safe = False
        except Exception:
            pass
        if safe:
            self._pass("IDOR — no sensitive data leakage detected")

    def test_path_traversal(self):
        """Test path traversal in file-related endpoints."""
        print("\n[5/10] Path Traversal")
        payloads = ["../../etc/passwd", "..\\..\\windows\\system32\\config\\sam", "%2e%2e%2f%2e%2e%2fetc%2fpasswd"]
        safe = True
        for payload in payloads:
            try:
                r = self._get(f"/content/download/{payload}", token=self.admin_token)
                if r.status_code == 200 and ("root:" in r.text or "SYSTEM" in r.text):
                    self._fail("Path Traversal", "CRITICAL", f"File access via: {payload[:30]}")
                    safe = False
                    break
            except Exception:
                pass
        if safe:
            self._pass("Path Traversal — no file leakage")

    def test_security_headers(self):
        """Check security headers on API responses."""
        print("\n[6/10] Security Headers")
        api_root = self.base.replace("/api/v1", "")
        try:
            r = self.session.get(f"{api_root}/docs", timeout=self.timeout)
            headers = r.headers
            missing = []
            if "x-content-type-options" not in headers:
                missing.append("X-Content-Type-Options")
            if "x-frame-options" not in headers and "content-security-policy" not in headers:
                missing.append("X-Frame-Options or CSP")
            if missing:
                self._fail("Security Headers", "LOW", f"Missing: {', '.join(missing)}")
            else:
                self._pass("Security Headers — all present")
        except Exception:
            self._pass("Security Headers — skipped (no response)")

    def test_sensitive_data_exposure(self):
        """Check for sensitive data in responses."""
        print("\n[7/10] Sensitive Data Exposure")
        safe = True
        if self.admin_token:
            try:
                r = self._get("/users", token=self.admin_token)
                if r.status_code == 200:
                    body = r.text
                    if "password_hash" in body or "password" in body.lower().replace("password_reset", ""):
                        # More precise check
                        data = r.json()
                        items = data if isinstance(data, list) else data.get("items", data.get("data", []))
                        if isinstance(items, list):
                            for item in items[:3]:
                                if isinstance(item, dict) and "password_hash" in item:
                                    self._fail("Sensitive Data Exposure", "HIGH", "password_hash in user list response")
                                    safe = False
                                    break
            except Exception:
                pass
        if safe:
            self._pass("Sensitive Data Exposure — no password hashes in responses")

    def test_jwt_manipulation(self):
        """Test JWT token manipulation."""
        print("\n[8/10] JWT Manipulation")
        safe = True
        # Test with invalid token
        try:
            r = self._get("/users", token="eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxIn0.")
            if r.status_code == 200:
                self._fail("JWT None Algorithm", "CRITICAL", "Server accepts 'none' algorithm JWT")
                safe = False
        except Exception:
            pass
        # Test with tampered token
        if self.user_token and safe:
            try:
                tampered = self.user_token[:-5] + "XXXXX"
                r = self._get("/users", token=tampered)
                if r.status_code == 200:
                    self._fail("JWT Signature Bypass", "CRITICAL", "Server accepts tampered JWT")
                    safe = False
            except Exception:
                pass
        if safe:
            self._pass("JWT Manipulation — invalid tokens rejected")

    def test_rbac_escalation(self):
        """Test role-based access control enforcement."""
        print("\n[9/10] RBAC Escalation")
        if not self.user_token:
            self._pass("RBAC Escalation — skipped (no user token)")
            return
        admin_endpoints = [
            "/admin/analytics/overview",
            "/admin/user-overview",
        ]
        escalated = []
        for ep in admin_endpoints:
            try:
                r = self._get(ep, token=self.user_token)
                if r.status_code == 200:
                    escalated.append(ep)
            except Exception:
                pass
        if escalated:
            self._fail("RBAC Escalation", "HIGH", f"Observer accessed admin endpoints: {', '.join(escalated)}")
        else:
            self._pass("RBAC Escalation — observer cannot access admin endpoints")

    def test_error_handling(self):
        """Test that errors don't leak internal details."""
        print("\n[10/10] Error Information Leakage")
        safe = True
        try:
            r = self._get("/nonexistent-endpoint-12345", token=self.admin_token)
            body = r.text.lower()
            leak_indicators = ["traceback", "file \"", "line ", "sqlalchemy", "psycopg", "internal server"]
            for indicator in leak_indicators:
                if indicator in body:
                    self._fail("Error Info Leak", "MEDIUM", f"Internal detail '{indicator}' in error response")
                    safe = False
                    break
        except Exception:
            pass
        if safe:
            self._pass("Error Handling — no internal details leaked")

    def run_all(self):
        """Run all penetration tests."""
        print("=" * 60)
        print("BehaviorOS Penetration Test Suite")
        print(f"Target: {self.base}")
        print(f"Time:   {datetime.now().isoformat()}")
        print(f"Admin token: {'OK' if self.admin_token else 'MISSING'}")
        print(f"User token:  {'OK' if self.user_token else 'MISSING'}")
        print("=" * 60)

        self.test_sql_injection()
        self.test_xss_reflection()
        self.test_auth_bypass()
        self.test_idor()
        self.test_path_traversal()
        self.test_security_headers()
        self.test_sensitive_data_exposure()
        self.test_jwt_manipulation()
        self.test_rbac_escalation()
        self.test_error_handling()

        # Summary
        critical = [f for f in self.findings if f["severity"] == "CRITICAL"]
        high = [f for f in self.findings if f["severity"] == "HIGH"]
        medium = [f for f in self.findings if f["severity"] == "MEDIUM"]
        low = [f for f in self.findings if f["severity"] == "LOW"]

        print("\n" + "=" * 60)
        print(f"Results: {self.tests_passed}/{self.tests_run} passed")
        print(f"Findings: {len(critical)} CRITICAL, {len(high)} HIGH, {len(medium)} MEDIUM, {len(low)} LOW")
        print("=" * 60)

        # Write JSON report
        report = {
            "timestamp": datetime.now().isoformat(),
            "target": self.base,
            "tests_run": self.tests_run,
            "tests_passed": self.tests_passed,
            "findings": self.findings,
            "summary": {
                "critical": len(critical),
                "high": len(high),
                "medium": len(medium),
                "low": len(low),
            }
        }

        os.makedirs(os.path.dirname(self.json_path) if os.path.dirname(self.json_path) else ".", exist_ok=True)
        with open(self.json_path, "w") as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        print(f"\nReport: {self.json_path}")

        return len(critical) == 0 and len(high) == 0


def main():
    parser = argparse.ArgumentParser(description="BHP Penetration Test")
    parser.add_argument("--base", default="http://localhost:8000/api/v1", help="API base URL")
    parser.add_argument("--json", default="reports/pentest.json", help="JSON report output path")
    args = parser.parse_args()

    runner = PentestRunner(args.base, args.json)
    success = runner.run_all()
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
